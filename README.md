# twn

Rustで記述された簡易的なスタックベース仮想マシンおよびアセンブラです。
独自の命令セット(`.twn`)をバイトコード(`.twnd`)に変換し、VM上で実行します。

## 構成

このプロジェクトは以下の3つのバイナリで構成されています。

- **`twnc`**: アセンブラ。ソースコード(`.twn`)をバイトコード(`.twnd`)にコンパイルします。
- **`twnvm`**: 仮想マシン。コンパイルされたバイトコードを実行します。
- **`twn`**: ドライバ。コンパイルから実行までを一括で行うラッパーコマンドです。

## ビルドとインストール

Rust環境が必要です。

```sh
cargo build --release
```

ビルド後、`target/release/`ディレクトリにバイナリが生成されます。
`twn`コマンドを使用する場合、`twnc`および`twnvm`がシステムのPATHに含まれている必要があります。

## 使い方

### 1. ソースコードの作成

拡張子 `.twn` のファイルを作成します（例: `example.twn`）。
以下の例は、計算結果を表示して正常終了するプログラムです。

```twn
PUSH 10
PUSH 20
ADD
; 結果(30)をASCII文字として出力するために調整（例として単純出力）
; 実際には数値の文字列変換が必要ですが、ここではデバッグ表示を使用
PUSH 2  ; SYSCALL: DUMP (スタック状態を表示)
SYSCALL
PUSH 0  ; 終了コード 0
PUSH 3  ; SYSCALL: EXIT
SYSCALL
```

### 2. 実行

**一括実行 (twnコマンド)**

ファイル名の拡張子を除いたベース名を引数に渡します。

```sh
# twnc, twnvmにPATHが通っている前提
twn example
```

**個別実行**

```sh
# コンパイル (example.twnd が生成される)
cargo run --bin twnc -- example.twn

# VMでの実行
cargo run --bin twnvm -- example.twnd
```

## サンプルコード

`examples/` ディレクトリにサンプルコードがあります。

### 数当てゲーム (0~9)

0から9までの数字を当てるゲームです。入力に対して `Less` (小さい), `Greater` (大きい), `OK` (正解) を返します。

**実行方法**

```sh
# コンパイル
cargo run --bin twnc -- examples/guess_number.twn

# 実行
cargo run --bin twnvm -- examples/guess_number.twnd
```

## 命令セット (Instruction Set)

大文字・小文字は区別されません。

| 命令               | オペコード | 説明                                                           |
| ------------------ | ---------- | -------------------------------------------------------------- |
| **システムコール** |            |                                                                |
| `SYSCALL`          | `0x00`     | スタックトップの値（サブコマンド）に応じた処理を実行する       |
| **スタック操作**   |            |                                                                |
| `PUSH <val>`       | `0x01`     | 値をスタックにプッシュする                                     |
| `POP`              | `0x02`     | スタックから値をポップして破棄する                             |
| `DUP`              | `0x03`     | スタックトップの値を複製する                                   |
| `SWAP`             | `0x04`     | スタックトップの2つの値を入れ替える                            |
| **算術演算**       |            | スタックから2つの値を取り出し演算結果をプッシュする (飽和演算) |
| `ADD`              | `0x10`     | 加算 (a + b)                                                   |
| `SUB`              | `0x11`     | 減算 (a - b)                                                   |
| `MUL`              | `0x12`     | 乗算 (a \* b)                                                  |
| `DIV`              | `0x13`     | 除算 (a / b)                                                   |
| `MOD`              | `0x14`     | 剰余 (a % b)                                                   |
| **即値演算**       |            | スタックの値と引数の値で演算する                               |
| `ADDI <val>`       | `0x15`     | 加算 (stack_val + val)                                         |
| `SUBI <val>`       | `0x16`     | 減算 (stack_val - val)                                         |
| `MULI <val>`       | `0x17`     | 乗算 (stack_val \* val)                                        |
| `DIVI <val>`       | `0x18`     | 除算 (stack_val / val)                                         |
| `MODI <val>`       | `0x19`     | 剰余 (stack_val % val)                                         |
| **比較演算**       |            | 条件成立時は `0`、不成立時は `1` をプッシュする (JZ用)         |
| `EQ`               | `0x1A`     | 等価 (a == b)                                                  |
| `NEQ`              | `0x1B`     | 不等価 (a != b)                                                |
| `LT`               | `0x1C`     | 小なり (a < b)                                                 |
| `LE`               | `0x1D`     | 以下 (a <= b)                                                  |
| `GT`               | `0x1E`     | 大なり (a > b)                                                 |
| `GE`               | `0x1F`     | 以上 (a >= b)                                                  |
| **制御構文**       |            |                                                                |
| `JZ <addr>`        | `0x20`     | スタックからポップし、値が0なら指定アドレスへジャンプ          |
| `JMZ <addr>`       | `0x21`     | 無条件ジャンプ (指定アドレスへ移動)                            |
| `CALL <addr>`      | `0x40`     | 現在の位置を保存して指定アドレスのサブルーチンへジャンプ       |
| `RET`              | `0x41`     | サブルーチンから復帰する                                       |
| `FIN`              | `0xFF`     | プログラムを終了する（正常終了、コード0）                      |
| **メモリ操作**     |            | メモリサイズは256バイト                                        |
| `STORE`            | `0x30`     | (Stack: `val`, `addr`) `val`を`addr`番地に保存                 |
| `LOAD`             | `0x31`     | (Stack: `addr`) `addr`番地の値を読み出しプッシュ               |
| `STOREI <addr>`    | `0x32`     | (Stack: `val`) `val`を即値`addr`番地に保存                     |
| `LOADI <addr>`     | `0x33`     | 即値`addr`番地の値を読み出しプッシュ                           |

### システムコール (SYSCALL) 詳細

`SYSCALL`命令実行前に、サブコマンド番号をスタックにプッシュしてください。

| ID  | 動作  | 引数 (Stack) | 説明                                                       |
| --- | ----- | ------------ | ---------------------------------------------------------- |
| `0` | READ  | なし         | 標準入力を1バイト読み、スタックにプッシュ（EOF等は0）      |
| `1` | PRINT | `val`        | スタックから値をポップし、ASCII文字として出力              |
| `2` | DUMP  | なし         | 現在のスタックとメモリの状態をデバッグ出力                 |
| `3` | EXIT  | `code`       | スタックから値をポップし、終了コードとしてプログラムを終了 |

### ラベル

末尾に `:` を付けることでラベルを定義できます。ジャンプやCALL命令の宛先として使用可能です。

```twn
PUSH 0
Loop:
    ADDI 1
    PUSH 2 ; SYSCALL: DUMP
    SYSCALL
    ; ... 条件分岐など
    JMZ Loop
```

## ライセンス

[LICENSE](./LICENSE) を参照してください。
